///////////////////////////////////////////////////////////
//  TaskProcessor.cs
//  Implementation of the Class TaskProcessor
//  Generated by Enterprise Architect
//  Created on:      10-mar-2020 14:50:53
//  Original author: smialek
///////////////////////////////////////////////////////////


using System;
using System.Collections.Generic;
using System.Threading;
using Baltic.DataModel.CAL;
using Baltic.DataModel.CALExecutable;
using Baltic.DataModel.Execution;
using Baltic.Engine.Utilities;
using Baltic.Engine.JobBroker;
using Baltic.Engine.MultiQueue;
using Baltic.Database.TaskRegistry;

namespace Baltic.Engine.TaskProcessor
{
	public class TaskProcessor : ITaskProcessor
	{
		private static string CopyInYAML = "copy-in";
		private static string CopyOutYAML = "copy-out";
		
		private ITokenMQDirect Queue;
		private ITaskProcessing TaskRegistry;
		private IJobBroker Broker;
	
		private static Dictionary<string,short> TaskLocks;
		// TODO - use a .NET semaphore mechanism + singleton

		public TaskProcessor()
		{
			if (null == TaskLocks)
				TaskLocks = new Dictionary<string, short>();
		}

		~TaskProcessor()
		{

		}
	
		/// 
		/// <param name="q"></param>
		/// <param name="tr"></param>
		/// <param name="b"></param>
		public void Init(ITokenMQDirect q, ITaskProcessing tr, IJobBroker b)
		{
			Queue = q;
			TaskRegistry = tr;
			Broker = b;
			//*test*
			Console.WriteLine(ConsoleString() + "INIT");
			//*test*
		}

		/// 
		/// <param name="tm"></param>
		public short PutTokenMessage(TokenMessage tm)
		{
			string mainQname;
			string qname,reverseQname;
			short ret = 0;//TODO
			CDataToken mainDT = null;
			bool ready = true;
		
			//*test*
			Console.WriteLine(ConsoleString() + "PutTokenMessage START" + "\n$$ " + tm);
			//*test*
    	
			LockTaskAccess(tm.TaskUid, 1); // TODO - CHANGE: lock from processing other messages until finished
		
			// Start JobBatch - check if all required-strong tokens are available
		
			CJobBatch batch = TaskRegistry.GetJobBatchForRequiredToken(tm);
			CJobBatch previousBatch = TaskRegistry.GetJobBatchForProvidedToken(tm);
			JobMessage jm = null;
		
			if (null != batch) {
				mainDT = batch.Tokens.Find(token => token.TokenNo == tm.TokenNo || -token.TokenNo == tm.TokenNo);
				bool simple = 1 == batch.Tokens.FindAll(t => DataBinding.Provided != t.Binding).Count && DataMultiplicity.Single.Equals(batch.Tokens[0].Multiplicity);
				mainQname = TaskMessageUtility.GetBatchQueueNameFromToken(tm, batch.Uid, mainDT.Depths, simple, null == previousBatch ? 0 : previousBatch.DepthLevel);
			
				//*test*
				Console.WriteLine("$$ ?ActivateJobBatch token=" + tm.TokenNo);
				//*test*
			
				if (0 > Queue.CheckQueue(mainQname)) {
					if (batch.DepthLevel < 0)
						batch.DepthLevel = simple ? (null == previousBatch ? 0 : previousBatch.DepthLevel) : tm.SeqStack.Count - mainDT.Depths.Count;
				
					//*test*
					Console.WriteLine("$$ ?ActivateJobBatch depth_level=" + batch.DepthLevel);
					//*test*
				
					BatchMessage bm = new BatchMessage() {
						TaskUid = tm.TaskUid,
						JobsQueueUid = mainQname,
						DepthLevel = batch.DepthLevel,
						YAML = YAMLUtility.GetBatchYAML(batch)
					};
					mainQname = TaskMessageUtility.GetQueueNameFromToken(tm, mainDT.Depths, false, batch.DepthLevel);
				
					List<JobMessage> cjms = new List<JobMessage>(); // A list of input copying JobMessages to be started
				
					foreach (CDataToken dt in batch.Tokens) {
						if (dt.TokenNo != mainDT.TokenNo) {
							qname = TaskMessageUtility.UpdateTokenInQueueName(mainQname, dt.TokenNo);
							reverseQname = TaskMessageUtility.getQueueNameForNegatedToken(qname);
							if (dt.Binding == DataBinding.RequiredStrong && 0 > Queue.CheckQueue(qname)
							                                             && 0 > Queue.CheckQueue(reverseQname)){
								ready = false;
								break;
							} else if (dt.Binding != DataBinding.Provided && !dt.Direct
							                                              && 0 < Queue.CheckQueue(reverseQname)){
								JobMessage cjm = new JobMessage(){ TaskUid = tm.TaskUid, YAML = CopyInYAML, SystemJob = true };
								cjm.RequiredPinQueues.Add("input", reverseQname);
								cjm.ProvidedPinTokens.Add("output", -dt.TokenNo);
								for (int i = 0; i<Queue.CheckQueue(reverseQname); i++)
									cjms.Add(cjm);
							}
						}
					}
					if (ready){
						ret += Broker.ActivateJobBatch(batch,bm,DetermineReservationRangeForBatch(batch));
						foreach (JobMessage cjm in cjms)
							ret+= Broker.ActivateJob(batch,cjm);
					}
				}
			
			}
		
			// Update token_no to negative or positive depending on whether copying is needed
		
			if (null != batch){ // the TokenMessage is required for batch
				if (0 < tm.TokenNo) { // and has positive token_no
					if (!mainDT.Direct) // copying is not needed
						tm.TokenNo = -tm.TokenNo;
				} else if (0 != tm.TokenNo) // and has negative token_no
					tm.TokenNo = -tm.TokenNo;
				else {
					LockTaskAccess(tm.TaskUid, -1); // TODO - CHANGE: unlock processing other messages before returning
					return -1;
				}
			}
		
			// Start Job - check if required-strong tokens are available and activate the Job
		
			CJob job = TaskRegistry.GetJobForRequiredToken(tm);
		
			if (null == job) {
				if (TaskRegistry.IsTaskProvidedToken(tm)) { // TokenMessage injected onto the external provided Pin
					batch = TaskRegistry.GetJobBatchForToken(tm);
					bool negative = 0 > tm.TokenNo;
					reverseQname = null;
					if (negative) {
						mainQname = TaskMessageUtility.GetQueueNameFromToken(tm, null, true, 0);
						if (-1 != batch.DepthLevel)
							reverseQname = TaskMessageUtility.GetQueueNameFromToken(tm, null, true, batch.DepthLevel, true);
					} else if (-1 != batch.DepthLevel) {
						mainQname = TaskMessageUtility.GetQueueNameFromToken(tm, null, true, batch.DepthLevel);
						reverseQname = TaskMessageUtility.GetQueueNameFromToken(tm, null, true, 0, true);
					} else {
						LockTaskAccess(tm.TaskUid, -1); // TODO - CHANGE: unlock processing other messages before returning
						return -1; // should not happen
					}
					tm.PinName = negative ? "output" : "input";
					if (null != reverseQname && 0 <= Queue.CheckQueue(reverseQname)) {
						jm = new JobMessage(){ TaskUid = tm.TaskUid, YAML = CopyOutYAML, SystemJob = true };
						jm.RequiredPinQueues.Add("input", negative ? reverseQname : mainQname);
						jm.RequiredPinQueues.Add("output", negative ? mainQname : reverseQname);
						ready = true;
					}
				} else if (null != batch) {
					mainQname = TaskMessageUtility.GetQueueNameFromToken(tm, null, true, null == previousBatch ? 0 : previousBatch.DepthLevel);
					tm.PinName = "input";
					if (ready){
						jm = new JobMessage(){ TaskUid = tm.TaskUid, YAML = CopyInYAML, SystemJob = true };
						jm.RequiredPinQueues.Add("input", mainQname);
						jm.ProvidedPinTokens.Add("output", tm.TokenNo);
					} else
						ready = true;
				} else {
					LockTaskAccess(tm.TaskUid, -1); // TODO - CHANGE: unlock processing other messages before returning
					return -1; // Incorrect TokenMessage
				}
			} else {
				batch = TaskRegistry.GetJobBatchForJob(job, tm.TaskUid);
				mainDT = job.Tokens.Find(token => token.TokenNo == tm.TokenNo);
				tm.PinName = mainDT.PinName;
			
				// Generate queue name for the input TokenMessage
				bool simple = 1 == job.Tokens.FindAll(t => DataBinding.Provided != t.Binding).Count && DataMultiplicity.Single.Equals(job.Tokens[0].Multiplicity);
				mainQname = TaskMessageUtility.GetQueueNameFromToken(tm, mainDT.Depths, simple, batch.DepthLevel);
			
				// Remove unwanted SeqTokens (the ones that were used to generate the queue name)
				ret += TaskMessageUtility.RemoveSeqTokensFromToken(tm, mainDT.Depths, simple, batch.DepthLevel);
		
				if (ready) {
					jm = new JobMessage() { TaskUid = tm.TaskUid, YAML = job.YAML, SystemJob = false };
					jm.RequiredPinQueues.Add(mainDT.PinName, mainQname);
		
					foreach (CDataToken dt in job.Tokens) {
						if (dt.TokenNo != mainDT.TokenNo) {
							qname = TaskMessageUtility.UpdateTokenInQueueName(mainQname, dt.TokenNo);
							if (dt.Binding != DataBinding.Provided) {
								jm.RequiredPinQueues.Add(dt.PinName, qname);
								if (dt.Binding == DataBinding.RequiredStrong && 0 > Queue.CheckQueue(qname)) {
									ready = false;
									break;
								}
							} else {
								jm.ProvidedPinTokens.Add(dt.PinName, dt.TokenNo);
								if (!jm.Split && DataMultiplicity.Multiple == dt.Multiplicity)
									jm.Split = true;
							}
						}
						if (!jm.Merge && 0 != dt.Depths.Count)
							jm.Merge = true;
					}
					if (ready && 0 <= Queue.CheckQueue(mainQname)) {
						if (jm.Merge) {
							ready = false;
						} else {
							int rf = Queue.CheckQueue(mainQname);
							foreach (CDataToken dt in job.Tokens)
								if (dt.TokenNo != mainDT.TokenNo) {
									qname = TaskMessageUtility.UpdateTokenInQueueName(mainQname, dt.TokenNo);
									if (dt.Binding == DataBinding.RequiredStrong && rf >= Queue.CheckQueue(qname)) {
										ready = false;
										break;
									}
								}
						}
					}
				}
			}
		
			//*test*
			Console.WriteLine(ConsoleString() + "PutTokenMessage FINISH: " + tm.MsgUid);
			//*test*
		
			// Put the message into one of the queues in the MultiQueue, the queue name is generated above
			ret += Queue.PutMessage(mainQname, tm);
		
			if (ready && null != jm)
				ret += Broker.ActivateJob(batch,jm);
		
			LockTaskAccess(tm.TaskUid, -1); // TODO - CHANGE: unlock processing other messages when finished
    	
			return ret;
		}
	
		/// 
		/// <param name="taskUid"></param>
		/// <param name="lockUnlock"></param>
		private short LockTaskAccess(string taskUid, short lockUnlock)
		{
			if (!TaskLocks.ContainsKey(taskUid))
				TaskLocks.Add(taskUid, 0);
			if (0 < lockUnlock) {
				while (0 != TaskLocks[taskUid]) {
					Thread.Sleep(100);
				}
				;
				TaskLocks[taskUid] = 1;
				return 1;
			}
			if (0 > lockUnlock) {
				TaskLocks[taskUid] = 0;
				return 0;
			}
			return -1;
		}
	
		private string ConsoleString()
		{
			return "$$ TaskProcessor " + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss.ffff") + " $$ ";
		}

		/// 
		/// <param name="batch"></param>
		private ResourceReservationRange DetermineReservationRangeForBatch(CJobBatch batch){
			ResourceReservationRange ret = new ResourceReservationRange();
			
			return ret;
		}

	}
}
//end TaskProcessor
