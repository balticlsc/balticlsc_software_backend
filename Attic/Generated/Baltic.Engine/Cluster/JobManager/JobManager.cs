///////////////////////////////////////////////////////////
//  JobSDK.cs
//  Implementation of the Class JobSDK
//  Generated by Enterprise Architect
//  Created on:      23-mar-2020 09:58:24
//  Original author: smialek
///////////////////////////////////////////////////////////


using System;
using System.Collections.Generic;
using Baltic.DataModel.CALExecutable;
using Baltic.Engine.Cluster;

namespace Baltic.Engine.Cluster.JobManager
{
	public class JobManager : IQueueConsumer, ITokens, IJobs {

		private ITokenMQ Queue;

		/// <summary>
		/// string - job_instance_uid
		/// </summary>
		private Dictionary<string,JobMessage> Jobs;
		/// <summary>
		/// string - job_instance_uid
		/// </summary>
		private Dictionary<string,IJob> JobHandles;
		private int BatchDepthLevel;
		/// <summary>
		/// string1 - job_instance_uid, string2 - pin_uid, long - counter
		/// </summary>
		private Dictionary<string,Dictionary<string,long>> MsgCounters;
		/// <summary>
		/// string - msg_uid
		/// </summary>
		private Dictionary<string,TokenMessage> TokenMessages;
		/// <summary>
		/// string1 - queue_uid, string2 - job_instance_uid
		/// </summary>
		private Dictionary<string,string> QueuesToJobs;
	
		public JobManager(){
			Jobs = new Dictionary<string, JobMessage>();
			JobHandles = new Dictionary<string, IJob>();
			MsgCounters = new Dictionary<string, Dictionary<string, long>>();
			TokenMessages = new Dictionary<string, TokenMessage>();
			QueuesToJobs = new Dictionary<string, string>();
			BatchDepthLevel = -1;
		}

		~JobManager(){

		}
	
		/// 
		/// <param name="q"></param>
		public void Init(ITokenMQ q){
			Queue = q;
		}
	
		///
		/// <param name="tm"></param>
		/// <param name="requiredMsgUid"></param>
		/// <param name="finalMsg"></param>
		public short PutTokenMessage(TokenMessage tm, string requiredMsgUid, bool finalMsg){
			if (null == tm || null == tm.SenderUid || null == requiredMsgUid) return -1;
			if (!Jobs.ContainsKey(tm.SenderUid)) return -2;
			if (!TokenMessages.ContainsKey(requiredMsgUid)) return -3;
			if (null == tm.SeqStack || 0 != tm.SeqStack.Count) return -4; // TODO - rzucić wyjątek
			JobMessage jm = Jobs[tm.SenderUid];
			if (!jm.ProvidedPinTokens.ContainsKey(tm.PinName)) return -5;
		
			tm.TokenNo = jm.ProvidedPinTokens[tm.PinName];
		
			TokenMessage oldTm = TokenMessages[requiredMsgUid];
			List<SeqToken> seqStack = TokenUtility.GenerateOutputSeqStack(jm.RequiredPinQueues[oldTm.PinName],
				oldTm,BatchDepthLevel,jm.Merge);
			if (jm.Split) {
				Dictionary<string,long> jobCounters = MsgCounters[tm.SenderUid];
				seqStack.Add(new SeqToken(){SeqUid=tm.SenderUid,No=jobCounters[tm.PinName],IsFinal=finalMsg});
				if (!finalMsg) 
					jobCounters[tm.PinName] = jobCounters[tm.PinName] + 1;
				else
					jobCounters[tm.PinName] = 0;
			}
		
			tm.SeqStack = seqStack;
			tm.TaskUid = TokenMessages[requiredMsgUid].TaskUid;
			tm.TokenNo = jm.ProvidedPinTokens[tm.PinName];
		
			return Queue.PutTokenMessage(tm);
		}
	
		///
		/// <param name="msgUids"></param>
		public short FinalizeTokenMessageProcessing(List<string> msgUids){
			short ret = 0;
			TokenMessage tm;
			foreach (string msg in msgUids)
				if (TokenMessages.ContainsKey(msg)) {
					tm = TokenMessages[msg];
					ret += Queue.AckTokenMessage(tm.QueueUid,tm);
					TokenMessages.Remove(msg);
				}
			return ret;
		}
		
		/// 
		/// <param name="depthLevel"></param>
		public short SetBatchDepthLevel(int depthLevel){
			BatchDepthLevel = depthLevel;
			return 0;
		}


		///
		/// <param name="job"></param>
		/// <param name="jm"></param>
		public short RegisterJob(IJob job, JobMessage jm){
			if (-1 == BatchDepthLevel) return -1;
			JobHandles.Add(jm.MsgUid,job);
			Jobs.Add(jm.MsgUid,jm);
			MsgCounters.Add(jm.MsgUid,new Dictionary<string, long>());
			// initialise message counters for the output pins to "0"
			foreach(KeyValuePair<string,long> counter in jm.ProvidedPinTokens) {
				MsgCounters[jm.MsgUid].Add(counter.Key,0);
			}
			
			foreach(KeyValuePair<string,string> q in jm.RequiredPinQueues) {
				if (!QueuesToJobs.ContainsKey(q.Value)) {
					QueuesToJobs.Add(q.Value,jm.MsgUid);
					Queue.RegisterWithQueue(q.Value,this);
				}
			}
			return 0;
		}
	
		/// 
		/// <param name="msg"></param>
		public short MessageReceived(Message msg){		
			if (null == msg || !(msg is TokenMessage)) return -1;
			TokenMessage tm = (TokenMessage) msg;
			TokenMessages.Add(tm.MsgUid,tm);
			
			// TODO - remove the SeqStack for a "solitary single pin" Message
		
			//*test*
			Console.WriteLine(consoleString() + "TokenReceived for Job: " + QueuesToJobs[tm.QueueUid] +
			                  "\nCN$$ " + tm);
			//*test*
		
			return (short) (10 * JobHandles[QueuesToJobs[tm.QueueUid]].TokenReceived(tm));
		}
	
		private string consoleString(){
			return "CN$$ JobManager " + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss.ffff") + " $$ ";
		}

	}
}//end JobSDK