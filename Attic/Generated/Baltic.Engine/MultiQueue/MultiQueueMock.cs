///////////////////////////////////////////////////////////
//  MultiQueue.cs
//  Implementation of the Class MultiQueue
//  Generated by Enterprise Architect
//  Created on:      13-mar-2020 15:20:58
//  Original author: smialek
///////////////////////////////////////////////////////////


using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Threading;
using Baltic.DataModel.CALExecutable;
using Baltic.Engine.Cluster;

namespace Baltic.Engine.MultiQueue
{
	public class MultiQueueMock {

		Dictionary<string, List<Message>> _mq;
		Dictionary<string, int> _reservations;
	
		// MOCK
		public Dictionary<string,IQueueConsumer> Consumers = new Dictionary<string, IQueueConsumer>();
		bool _semaphore = true;
		// MOCK

		public MultiQueueMock(){
			_mq = new Dictionary<string, List<Message>>();
			_reservations = new Dictionary<string, int>();
		}

		~MultiQueueMock(){

		}

		/// 
		/// <param name="queueName"></param>
		/// <param name="msg"></param>
		public short PutMessage(string queueName, Message msg){
			//*test*
			string msgTxt = (null==msg)?"null":msg.MsgUid;
			Console.WriteLine(ConsoleString() + " PutMessage START: " + msgTxt);
			//*test*
    	
			while (!_semaphore) {};
    	
			if (!_mq.ContainsKey(queueName)) {
				_mq.Add(queueName, new List<Message>());
				_reservations.Add(queueName,0);
			}
			if (null != msg){
				// TODO - przerzucić do wywołania ?
				msg.QueueUid = queueName;
				_mq[queueName].Add(msg);
			}
			//*test*
			Console.WriteLine(ConsoleString() + " PutMessage FINISH: " + 
			                  msgTxt + "\n:: " + ToString(queueName));
			//*test*
			return 0;
		}

		/// 
		/// <param name="queueName"></param>
		public short CheckQueue(string queueName){
			short ret;
			if (_mq.ContainsKey(queueName))
				ret = (short) (_mq[queueName].Count-_reservations[queueName]);
			else
				ret = -1;
			return ret;
			//return (short) (mq.ContainsKey(queue_name)?mq[queue_name].Count-reservations[queue_name]:-1);
		}
	
		public string ToString(string queueName){
			string ret = "";
			ret += "Queue: " + queueName + "\n";
			foreach (Message msg in _mq[queueName]) {
				ret += "\t" + msg.ToString();
			}
			return ret;
		}
	
		public override string ToString(){
			Dictionary<string,List<Message>> mqTmp = new Dictionary<string, List<Message>>(_mq);
			string ret = "";
			foreach(string key in mqTmp.Keys) {
				ret += "Queue: " + key + "\n";
				List<Message> lmTmp = new List<Message>(mqTmp[key]);
				foreach (Message msg in lmTmp) {
					ret += "\t" + Regex.Replace(msg.ToString(), @"\n\t", "\n\t\t") + "\n";
				}
			}
			return ret;
		}

		/// 
		/// <param name="queueName"></param>
		public Message GetMessage(string queueName){
			//*test*
			Console.WriteLine("=> GetMessage START");
			//*test*
			if (0 == _mq[queueName].Count - _reservations[queueName]) return null;
			Message ret = _mq[queueName][_reservations[queueName]];
			_reservations[queueName] = _reservations[queueName] + 1;
			//*test*
			Console.WriteLine(ret);
			Console.WriteLine("=> GetMessage FINISH\n");
			//*test*
			return ret;
		}

		/// 
		/// <param name="queueName"></param>
		/// <param name="msgUid"></param>
		public short RemoveMessage(string queueName, string msgUid){
			List<Message> queue = _mq[queueName];
			Message msg = queue.Find(m => m.MsgUid == msgUid);
			if (null == msg) return -1;
			if (queue.IndexOf(msg) > _reservations[queueName])
				return -1;
			queue.Remove(msg);
			_reservations[queueName] = _reservations[queueName] -1;
			return 0;
		}
	
		public void RunQueue(){
			Message ret;
			while (true) {
				_semaphore = false;
				foreach(KeyValuePair<string,List<Message>> queue in _mq) {
					if (0 < queue.Value.Count - _reservations[queue.Key]) {
						if (Consumers.ContainsKey(queue.Key)) {
							ret = queue.Value[_reservations[queue.Key]];
							Consumers[queue.Key].MessageReceived(ret);
							_reservations[queue.Key] = _reservations[queue.Key] + 1;
						}
					}
				}
				_semaphore = true;
				Thread.Sleep(200);
			}
		}
	
		private string ConsoleString(){
			return ":: MultiQueue " + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss.ffff") + " :: ";
		}

	}
}//end MultiQueue